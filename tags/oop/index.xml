<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>oop on code with satriyop</title>
    <link>http://satriyop.github.io/tags/oop/</link>
    <description>Recent content in oop on code with satriyop</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 05 May 2020 16:35:29 +0700</lastBuildDate>
    
	<atom:link href="http://satriyop.github.io/tags/oop/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>OOP : Polimorphism di Go</title>
      <link>http://satriyop.github.io/post/oop-polimorphism-go/</link>
      <pubDate>Tue, 05 May 2020 16:35:29 +0700</pubDate>
      
      <guid>http://satriyop.github.io/post/oop-polimorphism-go/</guid>
      <description>Bila kita mempunyai package dengan beberapa fungsionalitas/service yang sudah didefinisikan sedangkan kita mempunyai satu type atau beberapa type yang akan menyediakan fungsionalitas tersebut ke consumer (kode yang akan berkomunikasi dengan Package/Type kita tersebut) maka desain yang baik adalah consumer tidak tahu, type mana yang menyediakan fungsionalitas/service yang diconsume-nya. Consumer hanya tahu bahwa mereka berinteraksi secara polimorfik dengan sebuah type, dan fungsionalitas/service yang akan disediakan oleh type tersebut, tapi implementasi detilnya tidak akan kelihatan.</description>
    </item>
    
    <item>
      <title>OOP : Inheritance Composition di Go</title>
      <link>http://satriyop.github.io/post/oop-inheritance-composition-go/</link>
      <pubDate>Mon, 04 May 2020 13:16:17 +0700</pubDate>
      
      <guid>http://satriyop.github.io/post/oop-inheritance-composition-go/</guid>
      <description>Bagaimana caranya untuk reuse dari behavior sebuah object yang sudah ada ? secara umum ada dua hal yang bisa dilakukan :
 Inheritance Composition  Meskipun begitu di Go, memilih composition over inheritance, meski begitu mari kita singgung sedikit tentang inheritance supaya kita mendapatkan gambaran utuhnya.
Inheritance adalah strategi reuse dimana sebuah type adalah berdasarkan type yang lainnya (base type), sehingga meng-inherit atau mewarisi fungsionalitas dari base type tersebut. Seringkali digambarkan sebagai hubungan parent-child.</description>
    </item>
    
    <item>
      <title>OOP : Message Passing di Go</title>
      <link>http://satriyop.github.io/post/oop-message-passing-go/</link>
      <pubDate>Sat, 02 May 2020 16:55:13 +0700</pubDate>
      
      <guid>http://satriyop.github.io/post/oop-message-passing-go/</guid>
      <description>Definisi dari secara singkat dari Message Passing adalah mengirimkan message ke object, dan menyerahkan kendalinya ke object tersebut. Dalam pemgrograman berorientasi Object hal ini bisa diartikan juga, bahwa consumer hanya bisa melakukan request terhadap sebuah service, tapi bagaimana service tersebut diimplementasikan akan diserahkan kepada object itu sendiri.
Pendektatan yang bisa digunakan dalam melakukan message passing adalah dengan menggunakan :
 Interface Channel  Interface type PaymentOption interface { ProcessPayment(float32) bool } type CashAccount struct {} func (c *CashAccount) ProcessPayment(amount float32) bool {.</description>
    </item>
    
    <item>
      <title>OOP : Encapsulation di Go</title>
      <link>http://satriyop.github.io/post/oop-encapsulation-go/</link>
      <pubDate>Thu, 30 Apr 2020 16:09:30 +0700</pubDate>
      
      <guid>http://satriyop.github.io/post/oop-encapsulation-go/</guid>
      <description>Salah satu filosofi dalam pemrograman berorientasi object adalah bahwa consumer (dalam Go, bisa diartikan package lain yang ingin berinteraksi dengan package kita) tidak boleh terlalu banyak tahu tentang detil object yang akan di-consume/dipanggil.
Hal ini bisa diselesaikan dengan 2 hal secara umum yaitu Encapsulation dan Message Passing, kita bahas dahulu tentang encapsulation.
Dalam hal encapsulation berarti consumer dapat meminta/memanggil sebuah service (biasanya dalam bentuk method) pada object yang di-consume-nya, tanpa perlu tahu detail bagaimana service tersebut diimplementasikan (logika dan struktur datanya).</description>
    </item>
    
  </channel>
</rss>